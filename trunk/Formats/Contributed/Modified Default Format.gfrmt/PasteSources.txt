global DocPath -- The path to the document being editedglobal WindowDef -- The code used by Pashua to create the desired dialog boxglobal MMDef -- The bit of the code used by Pashua for displaying multimedia.global mmyshift -- The amount by which certain elements in dialogs are shifted in the y (vertical) direction when there is multimedia to display. Due to the way Pashua counts pixels from the bottom of the window and when there is multimedia some elements need to be moved up to make room.global noteyshift -- The amount by which certain elements in dialogs are shifted in the y (vertical) direction when there are notes to display. Due to the way Pashua counts pixels from the bottom of the window and when there is multimedia some elements need to be moved up to make room.global cursourpage -- The current value of the PAGE field in the source being pasted.global cursourdate -- The current value of the DATE field in the source being pasted.global cursourtext -- The current value of the TEXT field in the source being pasted.global cursourrole -- The current value of the ROLE field in the source being pasted.global cursourtitle -- The current value of the TITL field in the source being pasted.global PasteTag -- The TAG associated with the pasted dataglobal curmmrefs -- References to all the attached multimedia recordsglobal curnoterefs -- References to all the attached note recordstell application "GEDitCOM II"	set message visible to falseend telltell application "Finder"	set PasteData to (the clipboard)end telltell application "GEDitCOM II"	set message visible to false	tell front document				set sourstruc to ""		set props to properties				if window type of props is "BrowserController" then			set keystruc to key record of props			set keylevel to 0		else			try				set keyref to item 3 of (editing details of props)			on error				--display dialog "You need to select a non blank field" buttons {"OK"} default button 1				user option title "Error" message "You need to select a non blank field" buttons {"OK"}
				return			end try						set keylevel to level of keyref			if keylevel is 1 then							end if			if keylevel is 2 then				set keystruc to parent structure of keyref				set keylevel to level of parent structure of keyref			end if			if keylevel is 3 then				set keystruc to parent structure of parent structure of keyref				set keylevel to level of parent structure of parent structure of keyref			end if			if keylevel is 4 then				set keystruc to parent structure of parent structure of parent structure of keyref				set keylevel to level of parent structure of parent structure of parent structure of keyref			end if			if keylevel is 5 then				set keystruc to parent structure of parent structure of parent structure of parent structure of keyref				set keylevel to level of parent structure of parent structure of parent structure of parent structure of keyref			end if		end if				-- Find out if what is on the clipboard is actually the GEDCOM for a source		try			set PasteLev to first word of PasteData			set PasteTag to second word of PasteData		on error			set PasteLev to ""			set PasteTag to ""		end try				if PasteLev is not in {1, 2} and PasteTag is not "SOUR" then			-- Contents of clipboard is not a source			--display dialog "You have not copied a source to the clipboard" buttons {"OK"} default button 1			user option title "Error" message "You have not copied a source to the clipboard" buttons {"OK"}
			return		else			-- Contents of clipboard appears to be a source			--set diff to (keylevel + 1) - PasteLev			-- If the source on the clipboard is not at level 1 we need to loop through each line in the data to change the line numbers so that it is.			set diff to 1 - PasteLev			set newPasteData to ""			set numpara to (number of paragraphs in PasteData) - 1			repeat with p from 1 to numpara				set newPasteData to newPasteData & (word 1 of paragraph p of PasteData) + diff & (characters 2 thru (length of paragraph p of PasteData) of paragraph p of PasteData) as string				if p < numpara then					set newPasteData to newPasteData & return				end if			end repeat												begin undo			tell keystruc				-- As GEDitCOM does not allow the editing of the GEDCOM of say an event we need to teporarily paste the new sources at level 1 hence the change of line numbers above				-- We also need to count the number of structures in the record before and after pasting so that we can tell how many new sources we have				set existingged to gedcom of key record of props				set structs to number of structures of key record of props				set gedcom of key record of props to existingged & return & newPasteData				set structsnow to number of structures of key record of props								-- Repeat with each new source				repeat structsnow - structs times					repeat 1 times						tell structure (structs + 1) of key record of props							-- Get various detail from the source for use later							set sourref to contents							tell application "GEDitCOM II"								tell front document									set cursourtitle to (name of source id sourref)								end tell							end tell														set cursourpage to evaluate expression "PAGE"							set cursourdate to evaluate expression "DATA.DATE"							set cursourtext to evaluate expression "DATA.TEXT"							set cursourrole to evaluate expression "EVEN.ROLE"														set curmmrefs to find structures tag "OBJE" output "References"							repeat with m from 1 to number of items in curmmrefs								tell application "GEDitCOM II"									set item m of curmmrefs to (multimedia id (contents of item m of curmmrefs) of front document)								end tell							end repeat							set curnoterefs to find structures tag "NOTE" output "References"							repeat with n from 1 to number of items in curnoterefs								tell application "GEDitCOM II"									set item n of curnoterefs to (note id (contents of item n of curnoterefs) of front document)								end tell							end repeat														if cursourtext is not "" then								--if there are any returns at the end of cursourtext we need to remove them								set noreturns to false								repeat until noreturns									set noreturns to true									repeat 1 times										if last character of cursourtext is "
" then											set cursourtext to every character of cursourtext											set cursourtext to (items 1 thru ((number of items in cursourtext) - 1) of cursourtext) as string											set noreturns to false										end if									end repeat								end repeat																set cursourtext to my FindAndReplace(cursourtext, "
", "[return]")							end if														-- Having got the existing data send a reqest to Pashua to create the required dialog and analyse the data returned							-- Census sources are dealt with slightly differently to others as it is assumed the PAGE and DATE fields will not need to be changed and therefore no option is given							if "Census" is not in cursourtitle then																set WindowDef to my SetWindowDef("N", "S")								tell application "Finder"									set SourceData to my pashua_run(WindowDef, "", "")								end tell								activate								
								if SourceData is -1 then
									--There was an error
									return
								end if
											if cb of SourceData is not "1" then																		set newsourpage to (sourPage of SourceData as string)									set newsourdate to (sourDate of SourceData as string)									set newsourtext to (SourText of SourceData as string)									set newsourrole to (SourRole of SourceData as string)									if newsourtext is not "" then										--if there are any returns at the end of newsourtext we need to remove them										set noreturns to false										repeat until noreturns											set noreturns to true											repeat 1 times												if last word of newsourtext is "return" and last character of newsourtext is "]" then													set newsourtext to every character of newsourtext													set newsourtext to (items 1 thru ((number of items in newsourtext) - 8) of newsourtext) as string													set noreturns to false												end if											end repeat										end repeat										set newsourtext to my FindAndReplace(newsourtext, "[return]", "
")									end if								else									-- The cancelbutton (named "cancel" in the WindowDef string) was pressed									delete structure (structs + 1) of key record of props									exit repeat									return								end if							end if																					if "Census" is in cursourtitle then																set WindowDef to my SetWindowDef("Y", "S")								tell application "Finder"									set SourceData to my pashua_run(WindowDef, "", "")								end tell								activate								if cb of SourceData is not "1" then																		set newsourpage to cursourpage									set newsourdate to cursourdate									set newsourtext to (SourText of SourceData as string)									set newsourrole to (SourRole of SourceData as string)									--if there are any returns at the end of newsourtext we need to remove them									if newsourtext is not "" then										set noreturns to false										repeat until noreturns											set noreturns to true											repeat 1 times												if last word of newsourtext is "return" and last character of newsourtext is "]" then													set newsourtext to every character of newsourtext													set newsourtext to (items 1 thru ((number of items in newsourtext) - 8) of newsourtext) as string													set noreturns to false												end if											end repeat										end repeat										set newsourtext to my FindAndReplace(newsourtext, "[return]", "
")									end if								else									-- The cancelbutton (named "cancel" in the WindowDef string) was pressed									delete structure (structs + 1) of key record of props									exit repeat								end if							end if														-- Having got the new details reqired back from Pashua (which may of course not have changed from the original) we need to deal with them							-- Taking each in turn we need to make sure each is what the user entered in the dialog but additionally may need to create structures to hold the data where none existed before or delete structures where there was data before but the user no longer wants it.							if newsourpage is not "" then								set sourpagestruc to find structures tag "PAGE" output "references"								if sourpagestruc is {} then									set sourpagestruc to make new structure with properties {name:"PAGE"}								end if								tell item 1 of sourpagestruc									set contents of item 1 of sourpagestruc to newsourpage								end tell							else								if cursourpage is not "" then									--new entry has no PAGE but original had, so we need to delete									set sourpagestruc to find structures tag "PAGE" output "references"									delete item 1 of sourpagestruc								end if							end if														if newsourdate is not "" then								set sourdatastruc to find structures tag "DATA" output "references"								if sourdatastruc is {} then									set sourdatastruc to make new structure with properties {name:"DATA"}								end if								tell item 1 of sourdatastruc									set cursourdatestruc to find structures tag "DATE" output "references"									if cursourdatestruc is {} then										set cursourdatestruc to make new structure with properties {name:"DATE"}									end if									set contents of item 1 of cursourdatestruc to newsourdate								end tell							else								if cursourdate is not "" then									--new entry has no DATE but original had, so we need to delete									set cursourdatestruc to find structures tag "DATE" value cursourdate output "references"									set sourdatastruc to parent structure of item 1 of cursourdatestruc									delete item 1 of cursourdatestruc									if (count of structures in sourdatastruc) is 0 then										delete sourdatastruc									end if								end if							end if														if newsourtext is not "" then								set sourdatastruc to find structures tag "DATA" output "references"								if sourdatastruc is {} then									set sourdatastruc to make new structure with properties {name:"DATA"}								end if								tell item 1 of sourdatastruc									set cursourtextstruc to find structures tag "TEXT" output "references"									if cursourtextstruc is {} then										set cursourtextstruc to make new structure with properties {name:"TEXT"}									end if									set contents of item 1 of cursourtextstruc to newsourtext								end tell							else								if cursourtext is not "" then									--new entry has no TEXT but original had, so we need to delete									set cursourtext to my FindAndReplace(cursourtext, "[return]", "
")									set cursourtextstruc to find structures tag "TEXT" value cursourtext output "references"									set sourdatastruc to parent structure of item 1 of cursourtextstruc									delete item 1 of cursourtextstruc									if (count of structures in sourdatastruc) is 0 then										delete sourdatastruc									end if								end if							end if														if newsourrole is not "" then								set sourevenstruc to find structures tag "EVEN" output "references"								if sourevenstruc is {} then									set sourevenstruc to make new structure with properties {name:"EVEN"}								end if								tell item 1 of sourevenstruc									set cursourrolestruc to find structures tag "ROLE" output "references"									if cursourrolestruc is {} then										set cursourrolestruc to make new structure with properties {name:"ROLE"}									end if									set contents of item 1 of cursourrolestruc to newsourrole								end tell							else								if cursourrole is not "" then									--new entry has no ROLE but original had, so we need to delete									set cursourrolestruc to find structures tag "ROLE" value cursourrole output "references"									set sourevenstruc to parent structure of item 1 of cursourrolestruc									delete item 1 of cursourrolestruc									if (count of structures in sourevenstruc) is 0 then										delete sourevenstruc									end if								end if							end if														--Check to see if user opted to delete any multimedia and delete it							my DeleteMM(SourceData, structure (structs + 1) of key record of props)														--Check to see if user opted to delete any note and delete it							my DeleteNotes(SourceData, structure (structs + 1) of key record of props)													end tell												-- Finally we need to move the pasted source from its temporary position attached to the correct location						move structure (structs + 1) of key record of props to after last structure of keystruc					end repeat				end repeat							end tell			end undo action "Paste Source"					end if	end tellend tellon SetWindowDef(Census, WindowType)	-- Create a window definition string which will be used to	-- tell Pashua what types of GUI elements you need and	-- which default values (if any) should be used		set mmyshift to 0		if curnoterefs is not {} then		if number of items in curnoterefs > 4 then			set noteyshift to 60		else			set noteyshift to (20 * (number of items in curnoterefs)) + 20		end if	else		set noteyshift to 0	end if		if curmmrefs is not {} then		-- If there is any multimedia, get the details to add to the dialog		my GetMMDetail(noteyshift)	else		set MMDef to ""	end if		-- Get the GEDitCOM icon to add to the dialog	set myself to (path to me as string)	set iconPath to (characters 1 thru ((length of myself) - 16) of myself as string) & "images:AppProIcon.tiff"		-- Census sources show just the text from the source and the role. Others also show the page and date fields	-- so we need a factor to work out the vertical or y-shift of some of the elements to position them correctly 	--in the dialog box		if Census is not "Y" then		set srcyshift to 120	else		set srcyshift to 0	end if		-- This sets up the bits which are common to all event dialogs regardless of type	set WindowDef to "
# Set transparency: 0 is transparent, 1 is opaque
*.transparency=1

# Make sure the window 'floats' on top
*.floating=1

# Set window title
*.title = Source Detail

#Add the GEDitCOM icon
img.type = image
img.maxwidth = 65
img.path = " & POSIX path of iconPath & return & "

# Introductory text
txt.type = text
txt.default = Enter the details for " & cursourtitle & "
txt.height = 100
txt.width = 250

# Add an source text box
sourText.type = textbox
sourText.label = Source Text
sourText.width = 350
sourText.height = 100
sourText.default = " & cursourtext & "

# Add a Role field
sourRole.type = textfield
sourRole.label = Role in Event
sourRole.width = 350
sourRole.default = " & cursourrole & "


# Add a cancel button with default label
cb.type=cancelbutton

img.x = -10
img.y = " & 220 + mmyshift + noteyshift + srcyshift & "
txt.x = 70
txt.y = " & 255 + mmyshift + noteyshift + srcyshift & "
sourText.x = 70
sourText.y = " & 115 + mmyshift + noteyshift & "
sourRole.x = 70
sourRole.y = " & 55 + mmyshift + noteyshift & "

"		set WindowDef to WindowDef & MMDef		if curnoterefs is not {} then		-- If there are any notes, get the details to add to the dialog		my GetNoteDetail()	end if		-- Then if it is not a census add a couple of extra fields	if Census is not "Y" then		set WindowDef to WindowDef & "	

# Add a Page field
sourPage.type = textfield
sourPage.label = Page
sourPage.width = 250
sourPage.default = " & cursourpage & "

# Add a Date field
sourDate.type = textfield
sourDate.label = Date
sourDate.width = 250
sourDate.default = " & cursourdate & "

sourPage.x = 70
sourPage.y = " & 315 + mmyshift + noteyshift & "
sourDate.x = 70
sourDate.y = " & 255 + mmyshift + noteyshift & "
			"	end if	return WindowDef	end SetWindowDefon GetMMDetail(noteyshift)	(* This bit gets the multimedia and adds a thumbnail to the dialog so that the user can deselect them if required
	As Pashua tries to keep everything as simple as posible it has limited options for display positioning.
	More could probably be done usin GEDitCOM's commands to work out if an image is landscape or portrait and adjust
	the positioning values sent to Pashua accordingly.
	It also only handles a maximum of four images as otherwise they would be too small or flow onto two rows which 
	also complicates the positioning within the dialog. This is only likely to be an issue on a minimal number of occasions*)		set nummm to number of items in curmmrefs	if nummm > 4 then		set MMDef to "
mmmsg.type = text
mmmsg.label = Multimedia
mmmsg.y = " & 50 + noteyshift & "
mmmsg.x = 70
mmmsg.width=320
mmmsg.text = There are too many multimedia objects to display.[return]Continue pasting and delete afterwards if necessary."		set mmyshift to 65	else		set xshift to 70		set maxthumbheight to 0		repeat with m from 1 to nummm			tell application "Image Events"				-- start the Image Events application				launch				-- open the image file (Use the thumbnail if there is one or the original if there isn't"				try					set ImagePath to DocPath & "/thumbs/" & id of item m of curmmrefs & ".jpg"					set this_image to open DocPath & "/thumbs/" & id of item m of curmmrefs & ".jpg"					-- extract the property value					copy the dimensions of this_image to {xsize, ysize}				on error					try						tell application "GEDitCOM II"							set ImagePath to object path of item m of curmmrefs						end tell						set this_image to open ImagePath						-- extract the property value						copy the dimensions of this_image to {xsize, ysize}					on error
					    set myself to (path to me as string)		                set imagePath to (characters 1 thru ((length of myself) - 16) of myself as string) & "images:NoFile.tiff"						tell application "Finder"							set ImagePath to POSIX path of ImagePath						end tell						set this_image to open ImagePath						-- extract the property value						copy the dimensions of this_image to {xsize, ysize}					end try				end try								-- purge the open image data				close this_image			end tell						if xsize > ysize then				set thumbwidth to 80				if maxthumbheight < 80 * (ysize / xsize) then					set maxthumbheight to 80 * (ysize / xsize)				end if			else				set thumbwidth to 80 * (xsize / ysize)				set maxthumbheight to 80			end if						set mmnum to "mm" & m			if m is 1 then				set MMDef to "
" & mmnum & ".label = Multimedia" & return			end if			set MMDef to MMDef & "
" & mmnum & ".type = image
" & mmnum & ".border = 1
" & mmnum & ".maxwidth = 80
" & mmnum & ".maxheight = 80
" & mmnum & ".path = " & ImagePath & "
" & mmnum & ".y = " & 70 + noteyshift & "
" & mmnum & ".x = " & xshift & "

" & "Check" & mmnum & ".type = checkbox
" & "Check" & mmnum & ".label = 
" & "Check" & mmnum & ".default = 1
" & "Check" & mmnum & ".y = " & 50 + noteyshift & "
" & "Check" & mmnum & ".x = " & (xshift + ((thumbwidth / 2)) - 7) & "
"			set xshift to xshift + thumbwidth + 1		end repeat				set mmyshift to maxthumbheight + 55			end if	return {MMDef, mmyshift}	end GetMMDetailon GetNoteDetail()	(* This bit gets the notes and adds  to the dialog so that the user can deselect them if required.
	It only handles a maximum of four notes as otherwise the dialog would get too big*)		set numnotes to number of items in curnoterefs	if numnotes > 4 then		set WindowDef to WindowDef & "
notemsg.type = text
notemsg.label = Notes
notemsg.y = 45
notemsg.x = 70
notemsg.width=320
notemsg.text = There are too many notes to display.[return]Continue pasting and delete afterwards if necessary."	   set noteyshift to 60
	else		set xshift to 20		set notey to 0		repeat with n from 1 to numnotes			set nn to numnotes+1-n			set notenum to "note" & nn			set notetext to name of item nn of curnoterefs			if length of notetext > 50 then				set notetext to characters 1 thru 40 of notetext & "…"			end if			if nn is 1 then				set WindowDef to WindowDef & "
notemsg.type = text
notemsg.default = Notes
notemsg.y = " & 47 + (20 * numnotes) & "
notemsg.x = 70
"			end if			set WindowDef to WindowDef & "


" & "Check" & notenum & ".type = checkbox
" & "Check" & notenum & ".label = " & notetext & "
" & "Check" & notenum & ".default = 1
" & "Check" & notenum & ".y = " & 40 + notey & "
" & "Check" & notenum & ".x = 70
"			set notey to notey + 20		end repeat	end if	return WindowDef	end GetNoteDetailon DeleteMM(DialogData, pStructure)	-- There could be up to 4 items but due to the way Pashua returns the data we cannot count them	-- so we have to try each in turn	tell application "GEDitCOM II"		tell pStructure			try				if Checkmm1 of DialogData is "0" then					set deletelink to id of item 1 of curmmrefs					set mmstructs1 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs1						if parent structure of item x of mmstructs1 is pStructure then							delete item x of mmstructs1						end if					end repeat				end if			end try						try				if Checkmm2 of DialogData is "0" then					set deletelink to id of item 2 of curmmrefs					set mmstructs2 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs2						if parent structure of item x of mmstructs2 is pStructure then							delete item x of mmstructs2						end if					end repeat				end if			end try						try				if Checkmm3 of DialogData is "0" then					set deletelink to id of item 3 of curmmrefs					set mmstructs3 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs3						if parent structure of item x of mmstructs3 is pStructure then							delete item x of mmstructs3						end if					end repeat				end if			end try						try				if Checkmm4 of DialogData is "0" then					set deletelink to id of item 4 of curmmrefs					set mmstructs4 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs4						if parent structure of item x of mmstructs4 is pStructure then							delete item x of mmstructs4						end if					end repeat				end if			end try		end tell	end tell	end DeleteMMon DeleteNotes(DialogData, pStructure)	-- There could be up to 4 items but due to the way Pashua returns the data we cannot count them	-- so we have to try each in turn	tell application "GEDitCOM II"		tell pStructure			try				if Checknote1 of DialogData is "0" then					set deletelink to id of item 1 of curnoterefs					set notestructs1 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs1						if parent structure of item x of notestructs1 is pStructure then							delete item x of notestructs1						end if					end repeat				end if			end try						try				if Checknote2 of DialogData is "0" then					set deletelink to id of item 2 of curnoterefs					set notestructs2 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs2						if parent structure of item x of notestructs2 is pStructure then							delete item x of notestructs2						end if					end repeat				end if			end try						try				if Checknote3 of DialogData is "0" then					set deletelink to id of item 3 of curnoterefs					set notestructs3 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs3						if parent structure of item x of notestructs3 is pStructure then							delete item x of notestructs3						end if					end repeat				end if			end try						try				if Checknote4 of DialogData is "0" then					set deletelink to id of item 4 of curnoterefs					set notestructs4 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs4						if parent structure of item x of notestructs4 is pStructure then							delete item x of notestructs4						end if					end repeat				end if			end try		end tell	end tell	end DeleteNotes-- Glue code for interfacing from AppleScript to Pashua. Written by-- Carsten Blüm <carsten@bluem.net>, 10/2003-01/2006, with improvements-- contributed by Eddy Roosnek and Hans Haesler. You can use or modify-- this handler any way you like in your own scripts.-- Argument 1: Configuration string / window description-- Argument 2: Encoding to use; if empty, Pashua assumes "macroman"-- Argument 3: Folder that contains Pashua.app; if empty, default locations are searchedon pashua_run(WindowDef, encoding, appdir)		-- Create path for temporary file	set AppleScript's text item delimiters to ""	set tmpfile to ((path to temporary items folder as string) & "Pashua_" & (characters 3 thru end of ((random number) as string)) as string)		-- Write temporary file and fill it with the configuration string	set fhandle to open for access tmpfile with write permission	write (WindowDef as string) to fhandle	close access fhandle		-- Get temporary file's POSIX path	set posixtmpfile to POSIX path of tmpfile			set diskPath to (path to startup disk as string)	set userPath to path to "cusr" as string	set myself to (path to me as string)	tell application "Finder" to set myParentPath to (container of alias myself as string)		-- Try to find Pashua application	tell application "Finder"				-- Try to find it in the directory supplied as argument to this handler		if appdir is not "" then			if last character of appdir = ":" then				set dirsep to ""			else				set dirsep to ":"			end if			if item (appdir & dirsep & "Pashua.app") exists then				set pashua to appdir & dirsep & "Pashua.app:"			end if			-- Try to find it in this script application bundle		else if item (myself & "Contents:MacOS:Pashua") exists then			set pashua to myself			-- Try to find it in this script's parent's path		else if item (myParentPath & "Pashua.app") exists then			set pashua to (myParentPath & "Pashua.app:")			-- Try to find it in global application folder		else if item (diskPath & "Applications:Pashua.app") exists then			set pashua to (diskPath & "Applications:Pashua.app:")			-- Try to find it in user's application folder		else if item (userPath & "Applications:Pashua.app") exists then			set pashua to (userPath & "Applications:Pashua.app:")		else			--display dialog "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"} default button 1 with icon stop			tell application "GEDitCOM II"
			user option title "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"}			end Tell
			return -1		end if	end tell		-- Append binary position inside app bundle to "regular" path	-- and convert path from HFS to POSIX representation	set pashuabinary to (POSIX path of pashua) & "Contents/MacOS/Pashua"		-- Optionally, define the encoding as command-line argument	if encoding = "" then		set encodingArg to ""	else		set encodingArg to "-e " & encoding & " "	end if		-- Execute pashua and get the string returned	set pashuaCall to "'" & pashuabinary & "' " & encodingArg & "'" & posixtmpfile & "';sleep 0.001"		set pashuaResult to do shell script (pashuaCall)			-- Delete the temporary file	do shell script "rm -r " & posixtmpfile			-- Check whether the dialog was submitted at all.	-- If this is not the case, return an empty list	if pashuaResult = "" then		return {}	end if		-- Parse the result	set AppleScript's text item delimiters to return	set resultLines to text items of pashuaResult	set AppleScript's text item delimiters to ""	set recordComponents to {}	repeat with currentLine in resultLines		set eqpos to offset of "=" in currentLine		if eqpos is not 0 then			set varKey to word 1 of currentLine			try				set varValue to (text (eqpos + 1) thru end of currentLine)				-- Quote any quotation marks in varValue with a backslash.				-- The proper way to do this would be a handler, but as				-- all code for interfacing to Pashua should be as compact				-- as possible, we rather do it inline				set AppleScript's text item delimiters to "\""				set textItems to every text item of varValue				set AppleScript's text item delimiters to "\\\""				set varValue to textItems as string				set AppleScript's text item delimiters to ""			on error				set varValue to ""			end try			copy (varKey & ":\"" & varValue & "\"") to end of recordComponents		end if	end repeat		-- Return the record we read from the tmpfile	set AppleScript's text item delimiters to ", "	set resultList to (run script "return {" & (recordComponents as string) & "}")	set AppleScript's text item delimiters to {""}	return resultList	end pashua_runon FindAndReplace(textstring, oldstr, newstr)	repeat		set pos to (offset of oldstr in textstring)		if pos is 0 then			exit repeat		end if		set textstring to characters 1 thru (pos - 1) of textstring & newstr & characters (pos + (length of oldstr)) thru (length of textstring) of textstring as string	end repeat	return textstring	end FindAndReplace