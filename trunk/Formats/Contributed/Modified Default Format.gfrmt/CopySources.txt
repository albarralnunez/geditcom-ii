global keytypeglobal keyrefglobal spageglobal CenTitleproperty sortedlist : {}property scriptName : "Sort Sources"if CheckAvailable(scriptName, 1.6) is false then returntell application "GEDitCOM II"	set message visible to false
		tell front document				set sourstruc to ""		set eventstruc to ""				set props to properties		set keytype to (class of key record) as string						try			set keyref to item 3 of (editing details of props)		on error			--display dialog "You need to select a non blank field" buttons {"OK"} default button 1			user option title "Error" message "You need to select a non blank field" buttons {"OK"}			return		end try								set keylevel to level of keyref		tell parent structure of keyref			try				set parentstruc to parent structure of keyref				set sours to every structure whose name is "SOUR"			end try			if number of items in sours is 0 then				tell parent structure of parent structure of keyref					try						set parentstruc to parent structure of parent structure of keyref						set sours to every structure whose name is "SOUR"					end try					if number of items in sours is 0 then						tell parent structure of parent structure of parent structure of keyref							try								set parentstruc to parent structure of parent structure of parent structure of keyref								set sours to every structure whose name is "SOUR"							end try							if number of items in sours is 0 then								tell parent structure of parent structure of parent structure of parent structure of keyref									try										set parentstruc to parent structure of parent structure of parent structure of parent structure of keyref										set sours to every structure whose name is "SOUR"									end try								end tell							end if						end tell					end if				end tell			end if		end tell	end tell	if number of items in sours is 0 then		user option title "There don't appear to be any sources here" message ¬			"Please try again." buttons {"OK"}	end if			--Get names of sources for list	tell parentstruc		set numsours to number of items in sours		if numsours > 1 then			-- If there is more than one source give the user the option of which one to copy and allow copying of multiple sources			set sourlist to {}			repeat with s from 1 to numsours				set listitem to (evaluate expression "SOUR.i." & s & ".ABBR")				if listitem is "" then					set listitem to (evaluate expression "SOUR.i." & s & ".TITL")				end if				if listitem is "" then					set listitem to "Source ID " & (contents of item s of sours)				end if				if s is numsours then					set end of sourlist to listitem				else					set end of sourlist to listitem				end if			end repeat									set WindowDef to my SetWindowDef(sourlist)						tell application "Finder"				set SourceData to my pashua_run(WindowDef, "", "")			end tell			activate			
			if SourceData is -1 then
				--There was an error
				return
			end if
						if item 1 of item 1 of SourceData = "cb" and item 1 of item 2 of SourceData = "1" then				-- user clicked the cancel button				return			end if						set sourstocopy to {}			repeat with n from 1 to number of items in sours				set itemnum to my indexof("SourBox" & n, SourceData)				if item itemnum of item 2 of SourceData is "1" then					set end of sourstocopy to item n of sours				end if			end repeat		else			set sourstocopy to sours		end if	end tell		set copystring to ""	set numtocopy to number of items in sourstocopy	repeat with c from 1 to numtocopy		set copystring to copystring & gedcom of item c of sourstocopy	end repeat	try		set the clipboard to copystring	end tryend tellon SetWindowDef(sourlist)		set WindowDef to "
# Set transparency: 0 is transparent, 1 is opaque
*.transparency=1

# Make sure the window 'floats' on top
*.floating=1
"		-- Get the GEDitCOM icon to add to the dialog	set myself to (path to me as string)	set iconPath to (characters 1 thru ((length of myself) - 15) of myself as string) & "images:AppProIcon.tiff"	
			-- Add GEDitCOM's icon			set WindowDef to WindowDef & "
#Add the GEDitCOM icon
img.type = image
img.maxwidth = 65
img.x = -10
img.y = " & (30 * ((number of items in sourlist) + 1)) - 35 & "
img.path = " & POSIX path of iconPath & "
# Set window title
*.title = Select Sources

# Introductory text
txt.type = text
txt.default = Select the sources you wish to copy 
txt.height = 100
txt.width = 250
txt.x = 70
txt.y =" & 30 * ((number of items in sourlist) + 1) & "
"		repeat with s from 1 to (number of items in sourlist)		set WindowDef to WindowDef & "
# Add a check box for each available source
sourbox" & s & ".type = checkbox
sourbox" & s & ".label = " & item s of sourlist & "
sourbox" & s & ".default = 1
sourbox" & s & ".x = 70
sourbox" & s & ".y = " & 30 * ((number of items in sourlist) - s + 1) & "

# Add a cancel button with default label
cb.type=cancelbutton

"	end repeat	return WindowDefend SetWindowDef-- Glue code for interfacing from AppleScript to Pashua. Written by-- Carsten Blüm <carsten@bluem.net>, 10/2003-01/2006, with improvements-- contributed by Eddy Roosnek and Hans Haesler. You can use or modify-- this handler any way you like in your own scripts.-- Argument 1: Configuration string / window description-- Argument 2: Encoding to use; if empty, Pashua assumes "macroman"-- Argument 3: Folder that contains Pashua.app; if empty, default locations are searchedon pashua_run(WindowDef, encoding, appdir)		-- Create path for temporary file	set AppleScript's text item delimiters to ""	set tmpfile to ((path to temporary items folder as string) & "Pashua_" & (characters 3 thru end of ((random number) as string)) as string)		-- Write temporary file and fill it with the configuration string	set fhandle to open for access tmpfile with write permission	write (WindowDef as string) to fhandle	close access fhandle		-- Get temporary file's POSIX path	set posixtmpfile to POSIX path of tmpfile			set diskPath to (path to startup disk as string)	set userPath to path to "cusr" as string	set myself to (path to me as string)	tell application "Finder" to set myParentPath to (container of alias myself as string)		-- Try to find Pashua application	tell application "Finder"				-- Try to find it in the directory supplied as argument to this handler		if appdir is not "" then			if last character of appdir = ":" then				set dirsep to ""			else				set dirsep to ":"			end if			if item (appdir & dirsep & "Pashua.app") exists then				set pashua to appdir & dirsep & "Pashua.app:"			end if			-- Try to find it in this script application bundle		else if item (myself & "Contents:MacOS:Pashua") exists then			set pashua to myself			-- Try to find it in this script's parent's path		else if item (myParentPath & "Pashua.app") exists then			set pashua to (myParentPath & "Pashua.app:")			-- Try to find it in global application folder		else if item (diskPath & "Applications:Pashua.app") exists then			set pashua to (diskPath & "Applications:Pashua.app:")			-- Try to find it in user's application folder		else if item (userPath & "Applications:Pashua.app") exists then			set pashua to (userPath & "Applications:Pashua.app:")		else			--display dialog "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"} default button 1 with icon stop			tell application "GEDitCOM II"
			user option title "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"}			end Tell
			return -1		end if	end tell		-- Append binary position inside app bundle to "regular" path	-- and convert path from HFS to POSIX representation	set pashuabinary to (POSIX path of pashua) & "Contents/MacOS/Pashua"		-- Optionally, define the encoding as command-line argument	if encoding = "" then		set encodingArg to ""	else		set encodingArg to "-e " & encoding & " "	end if		-- Execute pashua and get the string returned	set pashuaCall to "'" & pashuabinary & "' " & encodingArg & "'" & posixtmpfile & "';sleep 0.001"	set pashuaResult to do shell script (pashuaCall)		-- Delete the temporary file	--tell application "Finder" to delete tmpfile	do shell script "rm -r " & posixtmpfile		-- Check whether the dialog was submitted at all.	-- If this is not the case, return an empty list	if pashuaResult = "" then		return {}	end if		-- Parse the result	set AppleScript's text item delimiters to return	set resultLines to text items of pashuaResult	set AppleScript's text item delimiters to ""	set recordComponents to {}	set varkeys to {}	set varValues to {}	repeat with currentLine in resultLines				set eqpos to offset of "=" in currentLine		if eqpos is not 0 then			set end of varkeys to word 1 of currentLine			try				set end of varValues to (text (eqpos + 1) thru end of currentLine)				-- Quote any quotation marks in varValue with a backslash.				-- The proper way to do this would be a handler, but as				-- all code for interfacing to Pashua should be as compact				-- as possible, we rather do it inline				set AppleScript's text item delimiters to "\""				set textItems to every text item of last item of varValues				set AppleScript's text item delimiters to "\\\""				set last item of varValues to textItems as string				set AppleScript's text item delimiters to ""			on error				set last item of varValues to ""			end try		end if	end repeat		set resultList to {varkeys, varValues}	return resultList	end pashua_runon indexof(theItem, theList) -- credits Emmanuel Levy	set oTIDs to AppleScript's text item delimiters	set AppleScript's text item delimiters to return	set theList to return & theList & return	set AppleScript's text item delimiters to oTIDs	try		-1 + (count (paragraphs of (text 1 thru (offset of (return & theItem & return) in theList) of theList)))	on error		0	end tryend indexof(* Activate GEDitCOM II (if needed) and verify acceptable
     version is running and a document is open. Return true
     or false if script can run.
*)on CheckAvailable(sName, vNeed)	tell application "GEDitCOM II"		set message visible to false		activate		if versionNumber < vNeed then			user option title "The script '" & sName & ¬				"' requires GEDitCOM II, Version " & vNeed & ¬				" or newer" message "Please upgrade and try again." buttons {"OK"}			return false		end if		if number of documents is 0 then			user option title "The script '" & sName & ¬				¬					"' requires a document to be open" message ¬				"Please open a document and try again." buttons {"OK"}			return false		end if	end tell	return trueend CheckAvailable