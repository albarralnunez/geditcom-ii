(*Place cross reference script for GEDitCOM II
	28 OCT 2011, by Simon Robbins
	Lastest Revisions: 26 NOV 2011
	
*)global keytypeglobal keyrefglobal SortTypeglobal fractionDoneglobal xreftypeproperty htmlstring : {}property tablerowstring : {}property headertable : {}property sortedlist : {}property eventOut : {"ADOP", "BAPM", "BIRT", "BLES", "BURI", "CENS", "CHR", "CHRA", "CONF", "CREM", "DEAT", "EDUC", "EMIG", "EVEN", "FCOM", "GRAD", "IMMI", "NATI", "NATU", "OCCU", "ORDN", "PROB", "RESI", "RETI", "WILL", "ANUL", "DIV", "DIVF", "ENGA", "MARB", "MARC", "MARL", "MARR", "MARS"}property eventName : {"Adoption", "Baptism", "Birth", "Blessing", "Burial", "Census", "Chritening", "Adult Christening", "Confirmation", "Cremation", "Death", "Education", "Emigration", "Generic Event", "First Communion", "Graduation", "Immigration", "Nationality", "Naturalisation", "Occupation", "Ordination", "Probate", "Residence", "Retirement", "Will", "Annulment", "Divorce", "Divorce Filed", "Engagement", "Marriage Blessing", "Marriage Contract", "Marriage Licence", "Marriage", "Marriage Settlement"}property scriptName : "Place Cross Reference"tell application "GEDitCOM II"		set message visible to false	set doc to front document	tell front document						set props to properties		try			set keytype to (class of key record) as string		on error			set keytype to ""		end try		if keytype is "«class gcPl»" then			set keytype to "place"		end if		set htmlstring to {}		set tablerowstring to {}				if keytype is not "place" then			user option title "Error" message "You need to select a place record" buttons {"OK"}			return		end if				set SortType to user choice prompt "Select the way you want the results to be sorted." list items {"Date", "Event", "Name", "Address"} title "Select sorting method" buttons {"OK", "Cancel"}		if item 1 of SortType is "Cancel" then			return		else			set SortType to item 1 of item 2 of SortType		end if				set xreftype to user option title "Match criteria" message "Do you want cross references which match the selected place exactly or do you want to include those which are subdivisions of the selected place." buttons {"Subdivisions", "Exact"}				tell application "GEDitCOM II"			set message visible to true		end tell				repeat with p from 1 to number of items in selected records of props			set thisPlace to item p of selected records of props			set Placestr to name of thisPlace			if xreftype is "Exact" then				set recs to (every gedcomRecord whose gedcom contains "2 PLAC " & Placestr)			else				set recs to (every gedcomRecord whose gedcom contains Placestr)			end if						my HandlePlaceRecord(thisPlace)									set fractionStepSize to 0.01 -- progress reporting interval			set nextFraction to fractionStepSize -- progress reporting interval			notify progress message "Finding events at the selected place"			repeat with r from 1 to number of items in recs				set thisRec to item r of recs				my HandleRecord(thisPlace, thisRec)				-- if time, notify GEDitCOM II of the amount done				set fractionDone to r / (number of items in recs)				if fractionDone > nextFraction then					notify progress fraction fractionDone					set nextFraction to nextFraction + fractionStepSize				end if			end repeat					end repeat				set tablerowstring to my |sortlist|(tablerowstring)				my getTableRows(tablerowstring)				set end of htmlstring to "</table></div>" & return			end tellend tellon HandlePlaceRecord(thisPlace)	tell application "GEDitCOM II"		set end of htmlstring to "<h2><a name='" & name of thisPlace & "'></a>" & name of thisPlace & "</h2>" & return	end tellend HandlePlaceRecordon HandleRecord(thisPlace, thisRec)	tell application "GEDitCOM II"		tell thisRec			if xreftype is "Exact" then				set refs to find structures tag "PLAC" value name of thisPlace output "references"			else				set temprefs to find structures tag "PLAC" output "references"				set refs to {}				repeat with t from 1 to number of items in temprefs					if contents of item t of temprefs ends with name of thisPlace then						set end of refs to item t of temprefs					end if				end repeat			end if			set numrefs to number of items in refs			repeat with refnum from 1 to numrefs				repeat 1 times					set thisEvntAttr to parent structure of item refnum of refs					set EventTyp to name of thisEvntAttr					try						set EventAddr to contents of structure named "ADDR" of thisEvntAttr					on error						set EventAddr to ""					end try										if EventAddr is not "" then						if last character of EventAddr is "
" then							set EventAddr to characters 1 thru ((length of EventAddr) - 1) of EventAddr as string						end if						set EventAddr to my findandreplace(EventAddr, "
", ", ")						--Just in case there were any commas already in the data or spaces at the end of a line we need to get rid of them						set EventAddr to my findandreplace(EventAddr, ",,", ",")						set EventAddr to my findandreplace(EventAddr, " ,", ",")											end if					set x to my findInList(EventTyp, eventOut)					try						set EventTyp to item x of eventName					on error						exit repeat					end try										set EventDate to event date user of thisEvntAttr					set thisRecord to parent structure of thisEvntAttr										if record type of thisRec is "FAM" then						set RecordName to alternate name of thisRecord						set RecordName to characters 1 thru ((length of RecordName) - 7) of RecordName as string					else						set RecordName to alternate name of thisRecord					end if					set RecID to id of thisRecord					try						set thisspan to "(" & life span of thisRecord & ")"					on error						set thisspan to ""					end try										if SortType is "Date" then						set SortString to event SDN of thisEvntAttr & "||" & name of thisRecord & thisspan					else if SortType is "Name" then						set SortString to name of thisRecord & thisspan & "||" & event SDN of thisEvntAttr					else if SortType is "Event" then						set SortString to EventTyp & "||" & event SDN of thisEvntAttr & name of thisRecord & thisspan					else if SortType is "Address" then						if EventAddr is "" then							set SortString to "zzzzz" & "||" & event SDN of thisEvntAttr & name of thisRecord & thisspan						else							set SortString to EventAddr & "||" & event SDN of thisEvntAttr & name of thisRecord & thisspan						end if					end if										set end of tablerowstring to (SortString as text) & "<tr><td>" & EventDate & "</td><td>" & EventTyp & " of " & "<a href='" & RecID & "'>" & RecordName & " " & thisspan & "</a></td><td>" & EventAddr & "</td><tr>" & return									end repeat			end repeat		end tell	end tellend HandleRecordon getTableRows(tablerowstring)	repeat with r from 1 to number of items in tablerowstring		set end of htmlstring to item r of tablerowstring	end repeatend getTableRowson findandreplace(textstring, oldstr, newstr)	repeat		set pos to (offset of oldstr in textstring)		if pos is 0 then			exit repeat		end if		set textstring to characters 1 thru (pos - 1) of textstring & newstr & characters (pos + (length of oldstr)) thru (length of textstring) of textstring as string	end repeat	return textstring	end findandreplaceon findInList(what, L)	repeat with i from 1 to count L		if item i of L is what then			return i		end if	end repeat	returnend findInListon |sortlist|(the_list)	tell application "GEDitCOM II"				set old_delims to AppleScript's text item delimiters		set AppleScript's text item delimiters to {ASCII character 10} -- always a linefeed		set list_string to (the_list as string)		set new_string to do shell script "echo " & quoted form of list_string & " | sort -f"		set new_list to (paragraphs of new_string)		set AppleScript's text item delimiters to old_delims						set fractionStepSize to 0.01 -- progress reporting interval		set nextFraction to fractionStepSize -- progress reporting interval		set fractionDone to 0		notify progress message "Tidying up"		set sortedlist to {}		repeat with i from 1 to number of items in new_list			try								if (characters 1 thru (offset of "||" in (item i of new_list)) of item i of new_list) as string ≠ (characters 1 thru (offset of "||" in (item (i + 1) of new_list)) of item (i + 1) of new_list) as string and SortType is not "Date" then					set item i of new_list to my findandreplace(item i of new_list, "<td>", "<td style='border-bottom-width: 2px;'>")				end if			end try									set end of sortedlist to ((characters (offset of "<tr>" in (item i of new_list)) thru (length of item i of new_list) of item i of new_list) as string) & return			-- if time, notify GEDitCOM II of the amount done			set fractionDone to i / (number of items in new_list)			if fractionDone > nextFraction then				notify progress fraction fractionDone				set nextFraction to nextFraction + fractionStepSize			end if					end repeat		return sortedlist	end tellend |sortlist|tell application "GEDitCOM II"	--set message visible to false	-- prepare report	set rpt to "<div>" & return		set rpt to rpt & "<h1>Place Record Cross Reference</h1>" & return		set rpt to rpt & "<br>" & return		set rpt to rpt & "<table border=1 cellspacing=0 cellpadding=0 width='95%'>" & return	set rpt to rpt & "<thead><tr><th width= 100>Date</th><th width=400>Event</th><th>Address</th></tr></thead>"		set rpt to rpt & (htmlstring as string) & return & "</table>" & return		-- end the report	set rpt to rpt & "</div>"end telltell application "GEDitCOM II"	--set message visible to false	tell front document		set newreport to make new report with properties {name:"Place Report", body:rpt}		show browser of newreport				tell application "Finder"			set screen_size to bounds of window of desktop			set screen_width to item 3 of screen_size			set screen_height to item 4 of screen_size		end tell		tell application "GEDitCOM II"			set br to bounds of front window			if screen_width > 1024 then				set item 1 of br to (screen_width - 1124) / 2				set item 3 of br to screen_width - ((screen_width - 1124) / 2)			else				set item 1 of br to 22				set item 3 of br to screen_width - 22			end if			set item 2 of br to 50			set item 4 of br to screen_height - 50			set bounds of front window to br		end tell			end tellend tell(* Activate GEDitCOM II (if needed) and verify acceptable
     version is running and a document is open. Return true
     or false if script can run.
*)on CheckAvailable(sName, vNeed)	tell application "GEDitCOM II"		set message visible to false		activate		if versionNumber < vNeed then			user option title "The script '" & sName & ¬				"' requires GEDitCOM II, Version " & vNeed & ¬				" or newer" message "Please upgrade and try again." buttons {"OK"}			return false		end if		if number of documents is 0 then			user option title "The script '" & sName & ¬				¬					"' requires a document to be open" message ¬				"Please open a document and try again." buttons {"OK"}			return false		end if	end tell	return trueend CheckAvailable