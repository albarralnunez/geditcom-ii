global DocPath -- The path to the document being editedglobal WindowDef -- The code used by Pashua to create the desired dialog boxglobal MMDef -- The bit of the code used by Pashua for displaying multimedia.global mmyshift -- The amount by which certain elements in dialogs are shifted in the y (vertical) direction when there is multimedia to display. Due to the way Pashua counts pixels from the bottom of the window and when there is multimedia some elements need to be moved up to make room.global noteyshift -- The amount by which certain elements in dialogs are shifted in the y (vertical) direction when there are notes to display. Due to the way Pashua counts pixels from the bottom of the window and when there is multimedia some elements need to be moved up to make room.global curdate -- The current value of the DATE field in the event being pasted.global curage -- The current value of the AGE field in the event being pasted.global husbcurage -- The current value of the HUSB.AGE field in the event being pasted.global wifecurage -- The current value of the WIFE.AGE field in the event being pasted.global cursourpage -- The current value of the PAGE field in the source being pasted.global cursourdate -- The current value of the DATE field in the source being pasted.global cursourtext -- The current value of the TEXT field in the source being pasted.global cursourrole -- The current value of the ROLE field in the source being pasted.global cursourtitle -- The current value of the TITL field in the source being pasted.global PasteTag -- The TAG associated with the pasted dataglobal keytype -- The type of recordglobal curmmrefs -- References to all the attached multimedia recordsglobal curnoterefs -- References to all the attached note recordstell application "GEDitCOM II"	set message visible to falseend tellproperty INDIEventList : {"ADOP", "BAPL", "BAPM", "BARM", "BASM", "BIRT", "BLES", "BURI", "CAST", "CENS", "CHR", "CHRA", "CONF", "CONL", "CREM", "DEAT", "DSCR", "EDUC", "EMIG", "ENDL", "EVEN", "FCOM", "GRAD", "IDNO", "IMMI", "NATI", "NATU", "NCHI", "NMR", "OCCU", "ORDN", "PROB", "PROP", "REFN", "RELI", "RESI", "RETI", "SLGC", "SSN", "TITL", "WAC", "WILL"}property FAMEventList : {"ANUL", "CENS", "DIV", "DIVF", "ENGA", "MARB", "MARC", "MARL", "MARR", "MARS", "NCHI", "REFN"}property DateOnlyEvts : {"BIRT"}property AgeOnlyEvts : {"CENS"}property PartSourDetail : {"CENS"}tell application "Finder"	set PasteData to (the clipboard)end telltell application "GEDitCOM II"	tell front document		-- First gather some information about the selected record		set props to properties		set keyRec to (key record of props)		set keytype to (class of key record) as string		set keyRecRef to (id of keyRec)		set keyDoc to (name of props)		set DocPath to path of props		--Sometimes we get the wrong class so correct if necessary		if keytype is "«class gcFa»" then			set keytype to "Family"		end if		if keytype is "«class gcIn»" then			set keytype to "Individual"		end if		if keytype is "«class gcSo»" then			set keytype to "Source"		end if		if keytype is "«class gcHe»" then			set keytype to "Header"		end if		if keytype is "«class gcSu»" then			set keytype to "Submitter"		end if		if keytype is "«class gcRe»" then			set keytype to "Repository"		end if		if keytype is "«class gcNo»" then			set keytype to "Note"		end if		if keytype is "«class gcOb»" then			set keytype to "Multimedia Object"		end if		if keytype is "«class gcLg»" then			set keytype to "Research Log"		end if								-- Find out if what is on the clipboard is actually the GEDCOM for an event		try			set PasteLev to first word of PasteData			set PasteTag to second word of PasteData		on error			set PasteLev to ""			set PasteTag to ""		end try								-- Now check to see if there was actually something on the clipboard and if so was it an event and appropriate for the selected record type				if PasteLev is not 1 then			if PasteTag is not in INDIEventList and PasteTag is not in FAMEventList then				--display dialog "You have not copied an event to the clipboard" buttons {"OK"} default button 1				user option title "Error" message "You have not copied an event to the clipboard" buttons {"OK"}				return			end if		end if				if keytype is not in {"Individual", "Family"} then			--display dialog "You cannot paste an event into a " & keytype & " record." buttons {"OK"} default button 1			user option title "Error" message "You cannot paste an event into a " & keytype & " record." buttons {"OK"}			return		end if				if keytype is "Family" and PasteTag is not in FAMEventList and PasteTag is in INDIEventList then			--display dialog "You have copied an individual event which cannot be pasted into a " & keytype & " record." buttons {"OK"} default button 1			user option title "Error" message "You have copied an individual event which cannot be pasted into a " & keytype & " record." buttons {"OK"}			return		end if				if keytype is "Individual" and PasteTag is not in INDIEventList and PasteTag is in FAMEventList then			--display dialog "You have copied an family event which cannot be pasted into a " & keytype & " record." buttons {"OK"} default button 1			user option title "Error" message "You have copied an family event which cannot be pasted into a " & keytype & " record." buttons {"OK"}			return		end if								(*Next try to get a date and age/ages from the data on the clipboard before pasting
				 It would be easier to paste the data first and then get the information using standard
		GEDitCOM Applescript commands but it looks better if the event is not pasted in the background
		with the original date only to have it changed later in the script*)						tell application "Finder"			if PasteTag is in INDIEventList and keytype is "Individual" then				set curdate to ""				set curage to ""				set paras to number of paragraphs in PasteData				repeat with p from 1 to paras					set datetest to offset of "2 DATE" in (paragraph p of PasteData)					set agetest to offset of "2 AGE" in (paragraph p of PasteData)					if datetest is 1 then						set curdate to (characters 8 thru (length of (paragraph p of PasteData)) of paragraph p of PasteData) as string					end if					if agetest is 1 then						set curage to (characters 7 thru (length of (paragraph p of PasteData)) of paragraph p of PasteData) as string					end if				end repeat			end if			if PasteTag is in FAMEventList and keytype is "Family" then				set curdate to ""				set husbcurage to ""				set wifecurage to ""				set paras to number of paragraphs in PasteData				repeat with p from 1 to paras					set datetest to offset of "2 DATE" in (paragraph p of PasteData)					set husbagetest to offset of "2 HUSB" in (paragraph p of PasteData)					set wifeagetest to offset of "2 WIFE" in (paragraph p of PasteData)					if datetest is 1 then						set curdate to (characters 8 thru (length of (paragraph p of PasteData)) of paragraph p of PasteData) as string					end if					if husbagetest is 1 then						set husbcurage to (characters 7 thru (length of (paragraph (p + 1) of PasteData)) of paragraph (p + 1) of PasteData) as string					end if					if wifeagetest is 1 then						set wifecurage to (characters 7 thru (length of (paragraph (p + 1) of PasteData)) of paragraph (p + 1) of PasteData) as string					end if				end repeat			end if						--Now see if there is any multimedia for the event			set curmmrefs to {}						repeat with p from 1 to paras				set mmtest to offset of "2 OBJE" in (paragraph p of PasteData)				if mmtest is 1 then					tell application "GEDitCOM II"						set end of curmmrefs to (multimedia id ((characters 8 thru (length of (paragraph p of PasteData)) of paragraph p of PasteData) as string) of front document)					end tell				end if			end repeat						--Now see if there is any note for the event			set curnoterefs to {}						repeat with p from 1 to paras				set notetest to offset of "2 NOTE" in (paragraph p of PasteData)				if notetest is 1 then					tell application "GEDitCOM II"						set end of curnoterefs to (note id ((characters 8 thru (length of (paragraph p of PasteData)) of paragraph p of PasteData) as string) of front document)					end tell				end if			end repeat					end tell				-- Having got the existing data send a reqest to Pashua to create the required dialog and analyse the data returned		if PasteTag is not "CENS" then			set WindowDef to my SetWindowDef("N", "E")		else			set WindowDef to my SetWindowDef("Y", "E")		end if		tell application "Finder"			set EventData to my pashua_run(WindowDef, "", "")		end tell				activate				if EventData is -1 then			--There was an error			return		end if				if cb of EventData is not "1" then			set newdate to ""			set newage to ""			if PasteTag is not "CENS" then				set newdate to (EventDate of EventData as string)			end if			if keytype is "Individual" then				if PasteTag is not "BIRT" then					set newage to (EventAge of EventData as string)				end if			else				set husbnewage to (HusbAge of EventData as string)				set wifenewage to (WifeAge of EventData as string)			end if					else			-- The cancelbutton (named "cancel" in the WindowDef string) was pressed			return		end if				-- Having got the new details reqired back from Pashua (which may of course not have changed from the original) we need to paste the data into GEDitCOM and deal with any changes		-- Taking each in turn we need to make sure each is what the user entered in the dialog but additionally may need to create structures to hold the data where none existed before or delete structures where there was data before but the user no longer wants it.				begin undo		tell keyRec			set existingged to gedcom of keyRec			set gedcom of keyRec to existingged & return & PasteData						-- We have just pasted the new data at the end of the recored and therefore it will usually be the last structure in the record			-- However if there was previously no changed date for the record but the user has selected to recored changed dates there will be a new changed date at the end and we need to work with the structure before last.			if name of last structure of keyRec is not "CHAN" then				--if gedcom of last structure of keyRec is PasteData then				set newstruct to last structure of keyRec			else				set newstruct to prev structure of last structure of keyRec			end if			tell newstruct				try					set curdate to structure named "DATE"				on error					set curdate to {}				end try								if name of newstruct is not "CENS" then					--Enter date for the event unless it is a census where all dates are the same in a given year					if newdate is not "" then						if curdate is {} then							make new structure with properties {name:"DATE", contents:newdate}						else							set contents of item 1 of curdate to newdate						end if					else						try							delete curdate						end try					end if				end if			end tell			--Sort the events so that the new event is in the correct position			set newstructged to gedcom of newstruct			tell keyRec				sort data (the events)				set numstruct to number of items in structures				repeat with s from 1 to numstruct					if gedcom of structure s of keyRec is newstructged then						set newstruct to (a reference to structure s of keyRec)					end if				end repeat			end tell			tell newstruct				--First work out if there is an existing age in the pasted data				try					set curage to structure named "AGE"				on error					set curage to {}				end try								if keytype is "Individual" then										if newage is not "" then						if curage is {} then							make new structure with properties {name:"AGE", contents:newage}						else							set contents of item 1 of curage to newage						end if					else						try							delete curage						end try					end if				else					--First work out if there is an existing age for the husband in the pasted data					set husbcurage to {}					try						set curhusbstruct to structure named "HUSB"						if curhusbstruct is not {} then							tell curhusbstruct								try									set husbcurage to structure named "AGE"								end try							end tell						end if					end try										if husbnewage is not "" then						if husbcurage is {} then							-- if the user has entered an age for the husband but one not already there we need to create the structure and enter it							set newhusbstruct to make new structure with properties {name:"HUSB"}							tell newhusbstruct								make new structure with properties {name:"AGE", contents:husbnewage}							end tell													else							-- if the user has entered an age and already exists we need to change it							set contents of husbcurage to husbnewage						end if					else						-- if the user has not entered an age for the husband we need to delete any existing structure						try							delete curhusbstruct						end try					end if															--Work out if there is an existing age for the wife in the pasted data					set wifecurage to {}					try						set curwifestruct to structure named "WIFE"						if curwifestruct is not {} then							tell curwifestruct								try									set wifecurage to structure named "AGE"								end try							end tell						end if					end try										if wifenewage is not "" then						if wifecurage is {} then							-- if the user has entered an age for the wife but one not already there we need to create the structure and enter it							set newwifestruct to make new structure with properties {name:"WIFE"}							tell newwifestruct								make new structure with properties {name:"AGE", contents:wifenewage}							end tell													else							-- if the user has entered an age and already exists we need to change it							set contents of wifecurage to wifenewage						end if					else						-- if the user has not entered an age for the wife we need to delete any existing structure						try							delete curwifestruct						end try					end if				end if								--Check to see if user opted to delete any multimedia and delete it				my DeleteMM(EventData, newstruct)								--Check to see if user opted to delete any note and delete it				my DeleteNotes(EventData, newstruct)							end tell												--Need to handle the sources now			set sourdeletions to {}			tell newstruct				set sours to find structures tag "SOUR" output "References"				set numsour to number of items in sours				repeat with s from 1 to numsour					repeat 1 times						set curmmrefs to {}						set curnoterefs to {}						set cursourtitle to evaluate expression "SOUR.i." & s & ".TITL"						tell item s of sours							set cursourpage to evaluate expression "PAGE"							set cursourdate to evaluate expression "DATA.DATE"							set cursourtext to evaluate expression "DATA.TEXT"							set cursourrole to evaluate expression "EVEN.ROLE"							set curmmrefs to find structures tag "OBJE" output "References"							repeat with m from 1 to number of items in curmmrefs								tell application "GEDitCOM II"									set item m of curmmrefs to (multimedia id (contents of item m of curmmrefs) of front document)								end tell							end repeat							set curnoterefs to find structures tag "NOTE" output "References"							repeat with n from 1 to number of items in curnoterefs								tell application "GEDitCOM II"									set item n of curnoterefs to (note id (contents of item n of curnoterefs) of front document)								end tell							end repeat							if cursourtext is not "" then								--if there are any returns at the end of cursourtext we need to remove them								set noreturns to false								repeat until noreturns									set noreturns to true									repeat 1 times										if last character of cursourtext is "
" then											set cursourtext to every character of cursourtext											set cursourtext to (items 1 thru ((number of items in cursourtext) - 1) of cursourtext) as string											set noreturns to false										end if									end repeat								end repeat																set cursourtext to my FindAndReplace(cursourtext, "
", "[return]")							end if														-- Having got the existing data send a reqest to Pashua to create the required dialog and analyse the data returned							-- Census sources are dealt with slightly differently to others as it is assumed the PAGE and DATE fields will not need to be changed and therefore no option is given							if "Census" is not in cursourtitle then																set WindowDef to my SetWindowDef("N", "S")								tell application "Finder"									set SourceData to my pashua_run(WindowDef, "", "")								end tell								activate																if cb of SourceData is not "1" then									if del of SourceData is "1" then										--User selected "Delete Source"										set end of sourdeletions to item s of sours										exit repeat									end if									set newsourpage to (sourPage of SourceData as string)									set newsourdate to (sourDate of SourceData as string)									set newsourtext to (SourText of SourceData as string)									set newsourrole to (SourRole of SourceData as string)									if newsourtext is not "" then										--if there are any returns at the end of newsourtext we need to remove them										set noreturns to false										repeat until noreturns											set noreturns to true											repeat 1 times												if last word of newsourtext is "return" and last character of newsourtext is "]" then													set newsourtext to every character of newsourtext													set newsourtext to (items 1 thru ((number of items in newsourtext) - 8) of newsourtext) as string													set noreturns to false												end if											end repeat										end repeat										set newsourtext to my FindAndReplace(newsourtext, "[return]", "
")									end if								else									-- The cancelbutton (named "cancel" in the WindowDef string) was pressed									delete newstruct									return								end if							end if																					if "Census" is in cursourtitle then																set WindowDef to my SetWindowDef("Y", "S")								tell application "Finder"									set SourceData to my pashua_run(WindowDef, "", "")								end tell								activate																if cb of SourceData is not "1" then									if del of SourceData is "1" then										--User selected "Delete Source"										--delete item s of sours										set end of sourdeletions to item s of sours										exit repeat									end if									set newsourpage to cursourpage									set newsourdate to cursourdate									set newsourtext to (SourText of SourceData as string)									set newsourrole to (SourRole of SourceData as string)									--if there are any returns at the end of newsourtext we need to remove them									if newsourtext is not "" then										set noreturns to false										repeat until noreturns											set noreturns to true											repeat 1 times												if last word of newsourtext is "return" and last character of newsourtext is "]" then													set newsourtext to every character of newsourtext													set newsourtext to (items 1 thru ((number of items in newsourtext) - 8) of newsourtext) as string													set noreturns to false												end if											end repeat										end repeat										set newsourtext to my FindAndReplace(newsourtext, "[return]", "
")									end if								else									-- The cancelbutton (named "cancel" in the WindowDef string) was pressed									delete newstruct									return								end if							end if														-- Having got the new details reqired back from Pashua (which may of course not have changed from the original) we need to deal with them							-- Taking each in turn we need to make sure each is what the user entered in the dialog but additionally may need to create structures to hold the data where none existed before or delete structures where there was data before but the user no longer wants it.							if newsourpage is not "" then								set sourpagestruc to find structures tag "PAGE" output "references"								if sourpagestruc is {} then									set sourpagestruc to make new structure with properties {name:"PAGE"}								end if								tell item 1 of sourpagestruc									set contents of item 1 of sourpagestruc to newsourpage								end tell							else								if cursourpage is not "" then									--new entry has no PAGE but original had, so we need to delete									set sourpagestruc to find structures tag "PAGE" output "references"									delete item 1 of sourpagestruc								end if							end if														if newsourdate is not "" then								set sourdatastruc to find structures tag "DATA" output "references"								if sourdatastruc is {} then									set sourdatastruc to make new structure with properties {name:"DATA"}								end if								tell item 1 of sourdatastruc									set cursourdatestruc to find structures tag "DATE" output "references"									if cursourdatestruc is {} then										set cursourdatestruc to make new structure with properties {name:"DATE"}									end if									set contents of item 1 of cursourdatestruc to newsourdate								end tell							else								if cursourdate is not "" then									--new entry has no DATE but original had, so we need to delete									set cursourdatestruc to find structures tag "DATE" value cursourdate output "references"									set sourdatastruc to parent structure of item 1 of cursourdatestruc									delete item 1 of cursourdatestruc									if (count of structures in sourdatastruc) is 0 then										delete sourdatastruc									end if								end if							end if														if newsourtext is not "" then								set sourdatastruc to find structures tag "DATA" output "references"								if sourdatastruc is {} then									set sourdatastruc to make new structure with properties {name:"DATA"}								end if								tell item 1 of sourdatastruc									set cursourtextstruc to find structures tag "TEXT" output "references"									if cursourtextstruc is {} then										set cursourtextstruc to make new structure with properties {name:"TEXT"}									end if									set contents of item 1 of cursourtextstruc to newsourtext								end tell							else								if cursourtext is not "" then									--new entry has no TEXT but original had, so we need to delete									set cursourtext to my FindAndReplace(cursourtext, "[return]", "
")									set cursourtextstruc to find structures tag "TEXT" value cursourtext output "references"									set sourdatastruc to parent structure of item 1 of cursourtextstruc									delete item 1 of cursourtextstruc									if (count of structures in sourdatastruc) is 0 then										delete sourdatastruc									end if								end if							end if														if newsourrole is not "" then								set sourevenstruc to find structures tag "EVEN" output "references"								if sourevenstruc is {} then									set sourevenstruc to make new structure with properties {name:"EVEN"}								end if								tell item 1 of sourevenstruc									set cursourrolestruc to find structures tag "ROLE" output "references"									if cursourrolestruc is {} then										set cursourrolestruc to make new structure with properties {name:"ROLE"}									end if									set contents of item 1 of cursourrolestruc to newsourrole								end tell							else								if cursourrole is not "" then									--new entry has no ROLE but original had, so we need to delete									set cursourrolestruc to find structures tag "ROLE" value cursourrole output "references"									set sourevenstruc to parent structure of item 1 of cursourrolestruc									delete item 1 of cursourrolestruc									if (count of structures in sourevenstruc) is 0 then										delete sourevenstruc									end if								end if							end if														--Check to see if user opted to delete any multimedia and delete it							my DeleteMM(SourceData, item s of sours)														--Check to see if user opted to delete any note and delete it							my DeleteNotes(SourceData, item s of sours)													end tell					end repeat				end repeat				-- delete the sources where the user selected the delete button				set deletenum to number of items in sourdeletions				repeat with d from 0 to deletenum - 1					delete item (deletenum - d) of sourdeletions				end repeat							end tell		end tell		end undo action "Paste Event"			end tellend tellon SetWindowDef(Census, WindowType)	-- Create a window definition string which will be used to	-- tell Pashua what types of GUI elements you need and	-- which default values (if any) should be used		set mmyshift to 0		if curnoterefs is not {} then		if number of items in curnoterefs > 4 then			set noteyshift to 60		else			set noteyshift to (20 * (number of items in curnoterefs)) + 20		end if	else		set noteyshift to 0	end if		if curmmrefs is not {} then		-- If there is any multimedia, get the details to add to the dialog		my GetMMDetail(noteyshift)	else		set MMDef to ""	end if		-- Get the GEDitCOM icon to add to the dialog	set myself to (path to me as string)	set iconPath to (characters 1 thru ((length of myself) - 14) of myself as string) & "images:AppProIcon.tiff"		if WindowType is "E" then		-- this bit sets up the main event details window				-- Some events show just a date, some just an age and some both so we need a factor to work out		-- the vertical or y-shift of some of the elements to position them correctly in the dialog box				if PasteTag is not in DateOnlyEvts and PasteTag is not in AgeOnlyEvts then			if keytype is "Individual" then				set evyshift to 60 -- Make space for two fields			else				set evyshift to 120 -- Make space for three fields			end if		else			if keytype is "Individual" then				set evyshift to 0 -- Make space for one field			else				-- assume that we have got to this point as record is a family and event requires ages only. Apart from BIRT, which doesn't apply to families, I can't think of a reason for having date only without ages so the code does not account for this eventuality				set evyshift to 60 -- Make space for two fields			end if		end if				-- This sets up the bits which are common to all event dialogs regardless of type		set WindowDef to "
		
# Set transparency: 0 is transparent, 1 is opaque
*.transparency=1

# Make sure the window 'floats' on top
*.floating=1

# Set window title
*.title = Event Detail

#Add the GEDitCOM icon
img.type = image
img.maxwidth = 65
img.path = " & POSIX path of iconPath & return & "
img.x = -10
img.y = " & 80 + mmyshift + noteyshift + evyshift & "

# Introductory text
txt.type = text	
txt.height = 100
txt.width = 250
txt.default = Enter the details for the event
txt.x = 70
txt.y = " & 115 + mmyshift + noteyshift + evyshift & "	

# Add a cancel button with default label
cb.type=cancelbutton

"		set WindowDef to WindowDef & MMDef						if curnoterefs is not {} then			-- If there are any notes, get the details to add to the dialog			my GetNoteDetail()		end if				if PasteTag is not in AgeOnlyEvts then			--Add a date field if required			set WindowDef to WindowDef & "

# Add a Date field
EventDate.type = textfield
EventDate.label = Date
EventDate.default = " & curdate & "
EventDate.width = 250
EventDate.x = 70
EventDate.y = " & 55 + mmyshift + noteyshift + evyshift & "
"		end if		if PasteTag is not in DateOnlyEvts then			--Add an age field if required						if keytype is "Individual" then				set WindowDef to WindowDef & "
	
# Add an age box
EventAge.type = textfield
EventAge.label = Age
EventAge.default= " & curage & "
EventAge.width = 100
EventAge.x = 70
EventAge.y = " & 55 + mmyshift + noteyshift & "
"			else								set WindowDef to WindowDef & "
# Add an age box for the husband
HusbAge.type = textfield
HusbAge.label = Husband's Age
HusbAge.default = " & husbcurage & "
HusbAge.width = 100
HusbAge.x = 70
HusbAge.y = " & 115 + mmyshift + noteyshift & "

# Add an age box for the wife
WifeAge.type = textfield
WifeAge.label = Wife's Age
WifeAge.default = " & wifecurage & "
WifeAge.width = 100
WifeAge.x = 70
WifeAge.y = " & 55 + mmyshift + noteyshift & "
"							end if		end if		return WindowDef			else				-- this bit sets up the source details window					-- Census sources show just the text from the source and the role. Others also show the page and date fields		-- so we need a factor to work out the vertical or y-shift of some of the elements to position them correctly 		--in the dialog box				if Census is not "Y" then			set srcyshift to 120		else			set srcyshift to 0		end if				-- This sets up the bits which are common to all event dialogs regardless of type		set WindowDef to "
# Set transparency: 0 is transparent, 1 is opaque
*.transparency=1

# Make sure the window 'floats' on top
*.floating=1

# Set window title
*.title = Source Detail

#Add the GEDitCOM icon
img.type = image
img.maxwidth = 65
img.path = " & POSIX path of iconPath & return & "

# Introductory text
txt.type = text
txt.default = Enter the details for " & cursourtitle & "
txt.height = 100
txt.width = 250

# Add an source text box
sourText.type = textbox
sourText.label = Source Text
sourText.width = 350
sourText.height = 100
sourText.default = " & cursourtext & "

# Add a Role field
sourRole.type = textfield
sourRole.label = Role in Event
sourRole.width = 350
sourRole.default = " & cursourrole & "

# Add a button with to delete the source
del.type=button
del.label = Delete Source

# Add a cancel button with default label
cb.type=cancelbutton

img.x = -10
img.y = " & 220 + mmyshift + noteyshift + srcyshift & "
txt.x = 70
txt.y = " & 255 + mmyshift + noteyshift + srcyshift & "
sourText.x = 70
sourText.y = " & 115 + mmyshift + noteyshift & "
sourRole.x = 70
sourRole.y = " & 55 + mmyshift + noteyshift & "

"		set WindowDef to WindowDef & MMDef				if curnoterefs is not {} then			-- If there are any notes, get the details to add to the dialog			my GetNoteDetail()		end if				-- Then if it is not a census add a couple of extra fields		if Census is not "Y" then			set WindowDef to WindowDef & "	

# Add a Page field
sourPage.type = textfield
sourPage.label = Page
sourPage.width = 250
sourPage.default = " & cursourpage & "

# Add a Date field
sourDate.type = textfield
sourDate.label = Date
sourDate.width = 250
sourDate.default = " & cursourdate & "

sourPage.x = 70
sourPage.y = " & 315 + mmyshift + noteyshift & "
sourDate.x = 70
sourDate.y = " & 255 + mmyshift + noteyshift & "
			"		end if	end if	return WindowDef	end SetWindowDefon GetMMDetail(noteyshift)	(* This bit gets the multimedia and adds a thumbnail to the dialog so that the user can deselect them if required
	As Pashua tries to keep everything as simple as posible it has limited options for display positioning.
	More could probably be done usin GEDitCOM's commands to work out if an image is landscape or portrait and adjust
	the positioning values sent to Pashua accordingly.
	It also only handles a maximum of four images as otherwise they would be too small or flow onto two rows which 
	also complicates the positioning within the dialog. This is only likely to be an issue on a minimal number of occasions*)		set nummm to number of items in curmmrefs	if nummm > 4 then		set MMDef to "
		
mmmsg.type = text
mmmsg.label = Multimedia
mmmsg.y = " & 50 + noteyshift & "
mmmsg.x = 70
mmmsg.width=320
mmmsg.text = There are too many multimedia objects to display.[return]Continue pasting and delete afterwards if necessary."		set mmyshift to 65	else		set xshift to 70		set maxthumbheight to 0		repeat with m from 1 to nummm			tell application "Image Events"				-- start the Image Events application				launch				-- open the image file (Use the thumbnail if there is one or the original if there isn't"				try					set ImagePath to DocPath & "/thumbs/" & id of item m of curmmrefs & ".jpg"					set this_image to open DocPath & "/thumbs/" & id of item m of curmmrefs & ".jpg"					-- extract the property value					copy the dimensions of this_image to {xsize, ysize}				on error					try						tell application "GEDitCOM II"							set ImagePath to object path of item m of curmmrefs						end tell						set this_image to open ImagePath						-- extract the property value						copy the dimensions of this_image to {xsize, ysize}					on error						set myself to (path to me as string)						set ImagePath to (characters 1 thru ((length of myself) - 14) of myself as string) & "images:NoFile.tiff"						tell application "Finder"							set ImagePath to POSIX path of ImagePath						end tell						set this_image to open ImagePath						-- extract the property value						copy the dimensions of this_image to {xsize, ysize}					end try				end try												-- purge the open image data				close this_image			end tell						if xsize > ysize then				set thumbwidth to 80				if maxthumbheight < 80 * (ysize / xsize) then					set maxthumbheight to 80 * (ysize / xsize)				end if			else				set thumbwidth to 80 * (xsize / ysize)				set maxthumbheight to 80			end if						set mmnum to "mm" & m			if m is 1 then				set MMDef to "
" & mmnum & ".label = Multimedia" & return			end if			set MMDef to MMDef & "
" & mmnum & ".type = image
" & mmnum & ".border = 1
" & mmnum & ".maxwidth = 80
" & mmnum & ".maxheight = 80
" & mmnum & ".path = " & ImagePath & "
" & mmnum & ".y = " & 70 + noteyshift & "
" & mmnum & ".x = " & xshift & "

" & "Check" & mmnum & ".type = checkbox
" & "Check" & mmnum & ".label = 
" & "Check" & mmnum & ".default = 1
" & "Check" & mmnum & ".y = " & 50 + noteyshift & "
" & "Check" & mmnum & ".x = " & (xshift + ((thumbwidth / 2)) - 7) & "
"			set xshift to xshift + thumbwidth + 1		end repeat				set mmyshift to maxthumbheight + 55			end if	return {MMDef, mmyshift}	end GetMMDetailon GetNoteDetail()	(* This bit gets the notes and adds  to the dialog so that the user can deselect them if required.
	It only handles a maximum of four notes as otherwise the dialog would get too big*)		set numnotes to number of items in curnoterefs	if numnotes > 4 then		set WindowDef to WindowDef & "
notemsg.type = text
notemsg.label = Notes
notemsg.y = 45
notemsg.x = 70
notemsg.width=320
notemsg.text = There are too many notes to display.[return]Continue pasting and delete afterwards if necessary."		set noteyshift to 60	else		set xshift to 20		set notey to 0		repeat with n from 1 to numnotes			set nn to numnotes+1-n			set notenum to "note" & nn			set notetext to name of item nn of curnoterefs			if length of notetext > 50 then				set notetext to characters 1 thru 40 of notetext & "…"			end if			if nn is 1 then				set WindowDef to WindowDef & "
notemsg.type = text
notemsg.default = Notes
notemsg.y = " & 47 + (20 * numnotes) & "
notemsg.x = 70
"			end if			set WindowDef to WindowDef & "


" & "Check" & notenum & ".type = checkbox
" & "Check" & notenum & ".label = " & notetext & "
" & "Check" & notenum & ".default = 1
" & "Check" & notenum & ".y = " & 40 + notey & "
" & "Check" & notenum & ".x = 70
"			set notey to notey + 20		end repeat	end if	return WindowDef	end GetNoteDetailon DeleteMM(DialogData, pStructure)	-- There could be up to 4 items but due to the way Pashua returns the data we cannot count them	-- so we have to try each in turn	tell application "GEDitCOM II"		tell pStructure			try				if Checkmm1 of DialogData is "0" then					set deletelink to id of item 1 of curmmrefs					set mmstructs1 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs1						if parent structure of item x of mmstructs1 is pStructure then							delete item x of mmstructs1						end if					end repeat				end if			end try						try				if Checkmm2 of DialogData is "0" then					set deletelink to id of item 2 of curmmrefs					set mmstructs2 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs2						if parent structure of item x of mmstructs2 is pStructure then							delete item x of mmstructs2						end if					end repeat				end if			end try						try				if Checkmm3 of DialogData is "0" then					set deletelink to id of item 3 of curmmrefs					set mmstructs3 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs3						if parent structure of item x of mmstructs3 is pStructure then							delete item x of mmstructs3						end if					end repeat				end if			end try						try				if Checkmm4 of DialogData is "0" then					set deletelink to id of item 4 of curmmrefs					set mmstructs4 to find structures tag "OBJE" value deletelink output "references"					repeat with x from 1 to number of items in mmstructs4						if parent structure of item x of mmstructs4 is pStructure then							delete item x of mmstructs4						end if					end repeat				end if			end try		end tell	end tell	end DeleteMMon DeleteNotes(DialogData, pStructure)	-- There could be up to 4 items but due to the way Pashua returns the data we cannot count them	-- so we have to try each in turn	tell application "GEDitCOM II"		tell pStructure			try				if Checknote1 of DialogData is "0" then					set deletelink to id of item 1 of curnoterefs					set notestructs1 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs1						if parent structure of item x of notestructs1 is pStructure then							delete item x of notestructs1						end if					end repeat				end if			end try						try				if Checknote2 of DialogData is "0" then					set deletelink to id of item 2 of curnoterefs					set notestructs2 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs2						if parent structure of item x of notestructs2 is pStructure then							delete item x of notestructs2						end if					end repeat				end if			end try						try				if Checknote3 of DialogData is "0" then					set deletelink to id of item 3 of curnoterefs					set notestructs3 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs3						if parent structure of item x of notestructs3 is pStructure then							delete item x of notestructs3						end if					end repeat				end if			end try						try				if Checknote4 of DialogData is "0" then					set deletelink to id of item 4 of curnoterefs					set notestructs4 to find structures tag "NOTE" value deletelink output "references"					repeat with x from 1 to number of items in notestructs4						if parent structure of item x of notestructs4 is pStructure then							delete item x of notestructs4						end if					end repeat				end if			end try		end tell	end tell	end DeleteNotes-- Glue code for interfacing from AppleScript to Pashua. Written by-- Carsten Blüm <carsten@bluem.net>, 10/2003-01/2006, with improvements-- contributed by Eddy Roosnek and Hans Haesler. You can use or modify-- this handler any way you like in your own scripts.-- Argument 1: Configuration string / window description-- Argument 2: Encoding to use; if empty, Pashua assumes "macroman"-- Argument 3: Folder that contains Pashua.app; if empty, default locations are searchedon pashua_run(WindowDef, encoding, appdir)		-- Create path for temporary file	set AppleScript's text item delimiters to ""	set tmpfile to ((path to temporary items folder as string) & "Pashua_" & (characters 3 thru end of ((random number) as string)) as string)		-- Write temporary file and fill it with the configuration string	set fhandle to open for access tmpfile with write permission	write (WindowDef as string) to fhandle	close access fhandle		-- Get temporary file's POSIX path	set posixtmpfile to POSIX path of tmpfile			set diskPath to (path to startup disk as string)	set userPath to path to "cusr" as string	set myself to (path to me as string)	tell application "Finder" to set myParentPath to (container of alias myself as string)		-- Try to find Pashua application	tell application "Finder"				-- Try to find it in the directory supplied as argument to this handler		if appdir is not "" then			if last character of appdir = ":" then				set dirsep to ""			else				set dirsep to ":"			end if			if item (appdir & dirsep & "Pashua.app") exists then				set pashua to appdir & dirsep & "Pashua.app:"			end if			-- Try to find it in this script application bundle		else if item (myself & "Contents:MacOS:Pashua") exists then			set pashua to myself			-- Try to find it in this script's parent's path		else if item (myParentPath & "Pashua.app") exists then			set pashua to (myParentPath & "Pashua.app:")			-- Try to find it in global application folder		else if item (diskPath & "Applications:Pashua.app") exists then			set pashua to (diskPath & "Applications:Pashua.app:")			-- Try to find it in user's application folder		else if item (userPath & "Applications:Pashua.app") exists then			set pashua to (userPath & "Applications:Pashua.app:")		else			--display dialog "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"} default button 1 with icon stop			tell application "GEDitCOM II"				user option title "Error" message "I can't find the Pashua application which is needed for this script." & return & return & "It looks like Pashua is neither in one of the standard locations nor in the folder this AppleScript is in." & return & return & "Pashua can be downloaded from:" & return & "http://www.bluem.net/en/mac/pashua/" buttons {"OK"}			end tell			return -1		end if	end tell		-- Append binary position inside app bundle to "regular" path	-- and convert path from HFS to POSIX representation	set pashuabinary to (POSIX path of pashua) & "Contents/MacOS/Pashua"		-- Optionally, define the encoding as command-line argument	if encoding = "" then		set encodingArg to ""	else		set encodingArg to "-e " & encoding & " "	end if		-- Execute pashua and get the string returned	set pashuaCall to "'" & pashuabinary & "' " & encodingArg & "'" & posixtmpfile & "'; sleep 0.001"			(* there seems to be an issue around this point when running the script embedded in a GEDitCOM format but not if it is run in Script editor. the sleep in the line above is an attemp to stop this*)	set pashuaResult to do shell script (pashuaCall)		-- Delete the temporary file	--tell application "Finder" to delete tmpfile	do shell script "rm -r " & posixtmpfile		-- Check whether the dialog was submitted at all.	-- If this is not the case, return an empty list	if pashuaResult = "" then		return {}	end if		-- Parse the result	set AppleScript's text item delimiters to return	set resultLines to text items of pashuaResult	set AppleScript's text item delimiters to ""	set recordComponents to {}	repeat with currentLine in resultLines		set eqpos to offset of "=" in currentLine		if eqpos is not 0 then			set varKey to word 1 of currentLine			try				set varValue to (text (eqpos + 1) thru end of currentLine)				-- Quote any quotation marks in varValue with a backslash.				-- The proper way to do this would be a handler, but as				-- all code for interfacing to Pashua should be as compact				-- as possible, we rather do it inline				set AppleScript's text item delimiters to "\""				set textItems to every text item of varValue				set AppleScript's text item delimiters to "\\\""				set varValue to textItems as string				set AppleScript's text item delimiters to ""			on error				set varValue to ""			end try			copy (varKey & ":\"" & varValue & "\"") to end of recordComponents		end if	end repeat		-- Return the record we read from the tmpfile	set AppleScript's text item delimiters to ", "	set resultList to (run script "return {" & (recordComponents as string) & "}")	set AppleScript's text item delimiters to {""}	return resultList	end pashua_runon FindAndReplace(textstring, oldstr, newstr)	repeat		set pos to (offset of oldstr in textstring)		if pos is 0 then			exit repeat		end if		set textstring to characters 1 thru (pos - 1) of textstring & newstr & characters (pos + (length of oldstr)) thru (length of textstring) of textstring as string	end repeat	return textstring	end FindAndReplace